#!/usr/bin/python

import fileinput, re, sys

patClass = '(?P<class>[a-zA-Z0-9_]+)'
patQClass = '(?P<class>[a-zA-Z0-9_.]+)' # with dots

reImport = re.compile(r'''\s*import %s;?''' % patQClass)
reExtends = re.compile(r'''\bextends\s+%s''' % patClass)
reStaticRef1 = re.compile(r'''static.*\b%s\.''' % patClass)
reStaticRef2 = re.compile(r'''static.*\bnew %s\s*\(''' % patClass)
reImplements = re.compile(r'''\bimplements\s+%s''' % patClass)
reMoreImplements = re.compile(r''',\s*%s''' % patClass)
root = "src/as"

def getImport (path):
    return path[:-3].replace('/', '.')

def getClass (imp):
    return imp[imp.rfind('.') + 1:]

def getPackage (imp):
    return imp[:imp.rfind('.')]

class File:
    def __init__ (self, path):
        self.imports = {}
        self.extends = {}
        self.implements = {}
        self.refers = {}
        self.path = path
        for line in fileinput.FileInput(root + "/" + path):
            m = reImport.match(line)
            if m: self.imports[m.group('class')] = True
            m = reExtends.search(line)
            if m: self.extends[m.group('class')] = True
            m = reStaticRef1.search(line)
            if m: self.refers[m.group('class')] = True
            m = reStaticRef2.search(line)
            if m: self.refers[m.group('class')] = True
        #print "imports for %s are %s" % (path, ", ".join(self.imports.keys()))
        #print "extends for %s are %s" % (path, ", ".join(self.extends.keys()))

    def hasImport (self, path):
        return self.imports.has_key(getImport(path))

    def uses (self, path):
        imp = getImport(path)
        if not self.imports.has_key(imp):
            if getPackage(getImport(self.path)) != getPackage(imp):
                return False
        cls = getClass(imp)
        return self.extends.has_key(cls) or self.refers.has_key(cls)


class Link:
    def __init__(self, src, dst):
        self.src = src
        self.dst = dst

class Node:
    def __init__(self, file):
        self.file = file
        self.incoming = {}
        self.outgoing = {}

class Graph:
    def __init__(self, links):
        self.links = links
        self.nodes = {}
        for link in self.links:
            self.node(link.src).outgoing[link.dst] = True
            self.node(link.dst).incoming[link.src] = True

    def node (self, file):
        if self.nodes.has_key(file):
            return self.nodes[file]
        return self.nodes.setdefault(file, Node(file))

    def uses (self, src, dst, within=1):
        '''Returns true if src uses dst within the given count of steps'''
        outgoing = self.node(src).outgoing
        if outgoing.has_key(dst): return True
        if within == 1: return False
        for file in outgoing.keys():
            if self.uses(file, dst, within - 1):
                return True
        return False

    def getPath (self, src, dst, within=1):
        outgoing = self.node(src).outgoing
        if outgoing.has_key(dst): return [src, dst]
        if within == 1: return None
        for file in outgoing.keys():
            path = self.getPath(file, dst, within - 1)
            if path != None: return [src] + path
        return None

    def printCycles (self, within=1):
        nodes = self.nodes.keys()
        for src in nodes:
            for dst in nodes:
                if src == dst: continue
                path = self.getPath(src, dst, within)
                if path != None and self.uses(dst, src, within):
                   print " -> ".join(map(lambda f: f.path, path))
            

class FileSet:
    def __init__(self, file=None, files=None):
        self.files = []
        self.graph = None
        if files != None: self.files = files
        if file != None:
            for path in fileinput.FileInput(file):
                file = File(path.rstrip())
                self.files.append(file)

    def reorder (self):
        files = self.files
        print "# Checking %d files" % len(files)
        graph = self.getGraph()

        i, j = (0, 1)
        while i < len(files) - 1:
            if graph.uses(files[i], files[j]):
                print "# Moving %s before %s" % (files[j].path, files[i].path)
                file = files[j]
                del files[j]
                files.insert(i, file)
                j = i + 1
            else:
                j = j + 1
                if j == len(files):
                   i = i + 1
                   j = i + 1

    def removeBases (self):
        bases = []
        files = self.files
        graph = self.getGraph()
        i, j = (0, 1)
        while i < len(files) - 1:
            if graph.uses(files[i], files[j]):
                print "# Removing base %s" % (files[j].path)
                bases.append(files[j])
                del files[j]
            elif graph.uses(files[j], files[i]):
                print "# Removing base %s" % (files[i].path)
                bases.append(files[i])
                del files[i]
                j = i + 1
            else:
                j = j + 1
    
            if j == len(files):
               i = i + 1
               j = i + 1
        
        return FileSet(files=bases)
    
    
    def split (self):
        bases = self.removeBases()
        if len(bases.files) == 0: return [self]
        bases.reorder()
        return bases.split() + [self]
    
    def paths (self):
        return map(lambda f: "%s\n" % f.path, self.files)

    def output (self, path, name):
        print "# Writing %s to %s" % (name, path)
        f = open(path, "w")
        try:
            for item in self.files:
                f.write("%s\n" % item.path)
        finally:
            f.close()

    def getGraph (self):
        if self.graph == None:
            links = []
            for i in self.files:
                for j in self.files:
                    if i == j: continue
                    if i.uses(j.path):
                        links.append(Link(i, j))
            self.graph = Graph(links)
        return self.graph

    def getImportGraph (self):
        if self.graph == None:
            links = []
            for i in self.files:
                for j in self.files:
                    if i == j: continue
                    if i.uses(j.path) or i.hasImport(j.path):
                        links.append(Link(i, j))
            self.graph = Graph(links)
        return self.graph
        
files = FileSet(sys.argv[1])

if not True:
    files.reorder()
    files.output("etc/asc-files-sorted.txt", "All files")

elif True:
    groups = files.split()

    for i in range(0, len(groups)):
        groups[i].output("etc/asc-files-%02d.txt" % i, "Group %d" % i)
else:
    graph = files.getImportGraph()
    graph.printCycles(int(sys.argv[2]))
